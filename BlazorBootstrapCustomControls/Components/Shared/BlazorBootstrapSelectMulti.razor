@* Bootstrap-based multi-select component. See README.md for the specification. *@
@using System.Collections.Generic
@typeparam TItem
@typeparam TValue
@inherits BlazorBootstrapSelectBase<TItem, TValue>

<BlazorBootstrapSelectMarkup TValue="TValue" Id="@_id"
                       Label="@Label"
                       Width="@Width"
                       AutoExpandVertically="@AutoExpandVertically"
                       Disabled="@Disabled"
                       Open="@_open"
                       DisplayText="@DisplayText"
                       IsPlaceholder="@IsPlaceholder"
                       ShowClearButton="@ShowClearButton"
                       ShouldShowClearButton="@ShouldShowClearButton"
                       IsMulti="true"
                       Items="@_items"
                       HighlightedIndex="@_highlightedIndex"
                       IsItemSelected="@IsItemSelected"
                       AdditionalAttributes="@AdditionalAttributes"
                       OnInputClick="@OnInputClick"
                       OnInputBlur="@OnInputBlur"
                       OnClear="@OnClear"
                       SelectItem="@SelectItem"
                       OnItemHover="@OnItemHover"
                       OnItemMouseDown="@OnItemMouseDown" />

@if (ValidationMessage != null)
{
  <ValidationMessage For="@ValidationMessage" />
}

@code {
  /// <summary>
  /// Gets or sets the array of selected values. Use @bind-Value for two-way data binding.
  /// </summary>
  [Parameter] public TValue[]? Value { get; set; }

  /// <summary>
  /// Gets or sets the callback that is invoked when the selected values change.
  /// </summary>
  [Parameter] public EventCallback<TValue[]?> ValueChanged { get; set; }

  /// <summary>
  /// Gets or sets the expression identifying the value to validate.
  /// Used with EditForm and ValidationMessage components for form validation.
  /// </summary>
  [Parameter] public Expression<Func<TValue[]?>>? ValidationMessage { get; set; }

  protected override string DisplayText
  {
    get
    {
      var v = Value ?? Array.Empty<TValue>();
      if (v.Length == 0) return PlaceholderText ?? "";
      return string.Join(", ", v.Select(val =>
        _items.FirstOrDefault(i => EqualityComparer<TValue>.Default.Equals(i.Value, val)).Text
        ?? val?.ToString()
        ?? ""));
    }
  }

  protected override bool IsPlaceholder => (Value?.Length ?? 0) == 0;

  protected override bool ShouldShowClearButton => (Value?.Length ?? 0) > 0;

  protected override bool IsItemSelected(TValue value) =>
    (Value ?? Array.Empty<TValue>()).Contains(value, EqualityComparer<TValue>.Default);

  protected override async Task OnClearValue()
  {
    await ValueChanged.InvokeAsync(Array.Empty<TValue>());
  }

  protected override async Task OnSelectItem(TValue value)
  {
    var arr = (Value ?? Array.Empty<TValue>()).ToList();
    var idx = arr.FindIndex(v => EqualityComparer<TValue>.Default.Equals(v, value));
    if (idx >= 0)
      arr.RemoveAt(idx);
    else
      arr.Add(value);
    await ValueChanged.InvokeAsync(arr.ToArray());
    StateHasChanged();
  }

  protected override async Task OnHandleEnterKey(int highlightedIndex)
  {
    var item = _items[highlightedIndex];
    var arr = (Value ?? Array.Empty<TValue>()).ToList();
    var idx = arr.FindIndex(v => EqualityComparer<TValue>.Default.Equals(v, item.Value));
    if (idx >= 0)
      arr.RemoveAt(idx);
    else
      arr.Add(item.Value);
    await ValueChanged.InvokeAsync(arr.ToArray());
    StateHasChanged();
  }
}
