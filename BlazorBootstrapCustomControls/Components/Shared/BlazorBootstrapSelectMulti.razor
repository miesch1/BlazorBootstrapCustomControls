@* Bootstrap-based multi-select component. See README.md for the specification. *@
@typeparam TItem
@inherits BlazorBootstrapSelectBase<TItem>

<BlazorBootstrapSelectMarkup Id="@_id"
                       Label="@Label"
                       Width="@Width"
                       AutoExpandVertically="@AutoExpandVertically"
                       Disabled="@Disabled"
                       Open="@_open"
                       DisplayText="@DisplayText"
                       IsPlaceholder="@IsPlaceholder"
                       ShowClearButton="@ShowClearButton"
                       ShouldShowClearButton="@ShouldShowClearButton"
                       IsMulti="true"
                       Items="@_items"
                       HighlightedIndex="@_highlightedIndex"
                       IsItemSelected="@IsItemSelected"
                       OnInputClick="@OnInputClick"
                       OnInputBlur="@OnInputBlur"
                       OnClear="@OnClear"
                       SelectItem="@SelectItem"
                       OnItemHover="@OnItemHover"
                       OnItemMouseDown="@OnItemMouseDown" />

@if (ValidationMessage != null)
{
  <ValidationMessage For="@ValidationMessage" />
}

@code {
  /// <summary>
  /// Gets or sets the array of selected values. Use @bind-Value for two-way data binding.
  /// </summary>
  [Parameter] public string[]? Value { get; set; }

  /// <summary>
  /// Gets or sets the callback that is invoked when the selected values change.
  /// </summary>
  [Parameter] public EventCallback<string[]?> ValueChanged { get; set; }

  /// <summary>
  /// Gets or sets the expression identifying the value to validate.
  /// Used with EditForm and ValidationMessage components for form validation.
  /// </summary>
  [Parameter] public Expression<Func<string[]?>>? ValidationMessage { get; set; }

  protected override string DisplayText
  {
    get
    {
      var v = Value ?? Array.Empty<string>();
      if (v.Length == 0) return PlaceholderText ?? "";
      return string.Join(", ", v.Select(val => _items.FirstOrDefault(i => i.Value == val).Text ?? val));
    }
  }

  protected override bool IsPlaceholder => (Value?.Length ?? 0) == 0;

  protected override bool ShouldShowClearButton => (Value?.Length ?? 0) > 0;

  protected override bool IsItemSelected(string value) => (Value ?? Array.Empty<string>()).Contains(value);

  protected override async Task OnClearValue()
  {
    await ValueChanged.InvokeAsync(Array.Empty<string>());
  }

  protected override async Task OnSelectItem(string value)
  {
    var arr = (Value ?? Array.Empty<string>()).ToList();
    if (arr.Contains(value))
      arr.Remove(value);
    else
      arr.Add(value);
    await ValueChanged.InvokeAsync(arr.ToArray());
    StateHasChanged();
  }

  protected override async Task OnHandleEnterKey(int highlightedIndex)
  {
    var item = _items[highlightedIndex];
    var arr = (Value ?? Array.Empty<string>()).ToList();
    if (arr.Contains(item.Value))
      arr.Remove(item.Value);
    else
      arr.Add(item.Value);
    await ValueChanged.InvokeAsync(arr.ToArray());
    StateHasChanged();
  }
}
